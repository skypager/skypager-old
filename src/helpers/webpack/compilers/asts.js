/**
 * @name compilers/asts
 * @description The ASTs compilers will generate a JSON AST Document for the given markdown or javascript source file.
 * @example
 *  
 *  project.compiler('asts', { pattern: '*.md' })
 */
import { stringify as qs } from "querystring"

/**
 * Builds a compiler configuration for generating AST Metadata
 *
 * @param  {Object} [options={}] The Options Hash
 * @param  {String} options.pattern - a glob or path-to-regexp style string that will be used to match files
 * @param  {String} options.filename - a webpack filename configuration value, used to determine output file filename
 * @param  {Array, Regexp, String, Function} options.rules - a path matching rule, similar to the ones used by webpack
 * @param  {Function} options.filter - a function that should return true if the entry point should be compiled.
 * @param  {Object} [context={}] The Context Hash - will be autogenerated by the calling project in most cases.
 * @return {Webpack Configurator API}              The Skypager Webpack configuration API
 */
export const configure = (options = {}, context = {}) => {
  const {
    rules,
    filter,
    tags = {},
    filename = "[name].js",
    loaderPrefix = "json",
    keyBy = "baseRelativePath",
    pattern = "*.(js|md)",
    useMemory = false,
  } = options
  const { compiler, project } = context

  const entry =
    options.entry ||
    project
      .query(pattern)
      .filter(result => {
        if (typeof filter === "function") {
          return options.filter.call(project, result.file.path, result)
        }

        if (typeof rules !== "undefined") {
          return testRule(rules, result.file.path)
        }

        return true
      })
      .keyBy(keyBy)
      .mapValues(result => `!!${loaderPrefix}!skypager-ast?${qs(tags)}!${result.file.path}`)
      .mapKeys((v, k) => k.replace(/\.\w+$/, ""))
      .value()

  return project.compiler("node", { useMemory, ...options }).configure(c =>
    c
      .sourcemap(options.sourcemap || false)
      .output({
        path: project.paths.ast,
        filename,
        libraryTarget: "commonjs2",
      })
      .entry(entry),
  ).config
}

export function wrapArtifact(moduleCode) {
  try {
    const compiler = this
    const project = compiler.project

    return Promise.resolve(moduleCode).then(code => project.createModule(code).exports)
  } catch (e) {
    return Promise.resolve({
      code: moduleCode,
      error: e,
    })
  }
}
